**** ISR도 찾아서 정리해놓기



Q. 클라이언트 사이드 렌더링(CSR)과 서버 사이드 렌더링(SSR)에 대해 설명하고, 장/단점을 설명하라

A.
CSR과 SSR은 웹 페이지의 컨텐츠를 렌더링하는 방식. 어느 쪽에서 렌더링을 준비하느냐에 따라 개념이 나뉨

[어느 쪽에서 렌더링?]
CSR : 클라이언트 측에서 웹 페이지를 렌더링하는 방식. 일반적으로 SPA에서 많이 볼 수 있는 렌더링 방식.
SSR : 서버 측에서 렌더링하는 방식. 클라이언트가 페이지를 '요청할 때마다' 서버는 매번 새로운 HTML을 생성 (데이터가 자주 달라져 미리 만들어두기 어려운 페이지에 적합)

[동작 방식]
CSR :
1. 유저가 웹 사이트에 방문하면
2. 브라우저는 서버에 콘텐츠를 요청
3. 서버는 빈 뼈대만 있는 HTML과 JS파일을 응답으로 보내줌
4. 브라우저는 서버로부터 JS파일을 다운받고, JS를 이용해 동적으로 DOM을 만들어 브라우저에 렌더링

SSR :
1. 유저가 웹 사이트에 방문하면
2. 브라우저가 서버로 콘텐츠를 요청
3. 서버에서는 필요한 데이터를 얻어와 삽입한 후 CSS까지 모두 적용되어 렌더링 준비를 마친 HTML과, JS코드(HTML에 로직 연결되지는 않은 상태)를 브라우저에 응답으로 전달
4. 브라우저에서는 전달받은 페이지를 바로 렌더링
5. 이후 브라우저가 JS코드를 다운로드하고, HTML에 JS 로직을 연결


[장, 단점]
CSR
    - 장점
    - 화면 깜빡임이 없음 (필요한 부분만 동적으로 갱신하므로)
    - 초기 로딩 이후 구동 속도가 빠름 (초기 로드 이후 페이지 변경 시 데이터만 요청하면 됨)
    - TTV(time to view)와 TTI(tiem to interact) 사이 간극이 없음 -> UX 향상
    - 서버 부하가 클라이언트로 분산 (서버에서는 뼈대만 있는 HTML을 넘겨주기만 하면 됨)
    - 매끄러운 UX (클라이언트에서 동적으로 뷰 갱신하므로 인터렉션 반응이 빠름)

    - 단점
    - 초기 로딩 속도가 느림 (브라우저가 JS파일을 다운받고 동적으로 DOM 생성해야 하는 시간)
    - SEO에 불리 (웹 크롤러가 읽는 HTML이 텅텅 비어서.. JS 실행 후에만 전체 페이지 내용이 완성 -> 검색 엔진이 색인할 만한 콘텐츠가 X)
SSR
    - 장점
    - 초기 구동 속도가 빠름 (JS 다운받아 실행 전 사용자가 화면을 볼 수 있음)
    - SEO에 유리 (모든 데이터 정보가 담긴 채로 브라우저로 전달, 크롤러봇이 HTML 읽을 수 있음)

    - 단점
    - 화면 깜빡임 있음 (새 요청마다 전체 페이지를 렌더링하므로 새로고침되어서)
    - TTV와 TTI 사이 간극 (JS 다운 전 화면을 볼 수 있어서 다운받을 때까지 TTI는 안됨 -> 정적인 상태)
    - 서버 부하 우려 (각 사용자 요청마다 서버에서 전체 페이지 렌더링해야 하므로)
    - CSR보다는 비교적 나쁜 UX (각 사용자 요청마다 렌더링)



+a, SSG란?
- Static Site Generation
- 서버에서 HTML을 보내주는 측면에서는 SSR과 동일하지만, 언제 만들어 놓느냐의 관점에서 차이
- 서버에서 미리 HTML을 모두 만들어두기 때문에 바뀔 일이 거의 없는 페이지에 적합
ex. gatsby


[CSR 단점 보완 방법]
- 초기 DOM 생성 속도 줄이기
    : code splitting, tree-shaking, chunk 분리 통해 초기 DOM 생성 속도 줄여 초기 로딩 속도 보완
- pre-rendering 통한 SEO 개선
    : 웹 라이브러리, 웹팩 플러그인을 통해 각 페이지에 대한 HTML파일 미리 생성한 뒤 서버에서 요청하는 자가 웹 크롤러라면
    사전 렌더링된 HTML 버전 페이지를 보여주는 방식을 통해 개선 가능
- CSR을 사용하는 SPA에 SSR이나 SSG를 도입


[CSR에 SSR이나 SSG를 도입하는 방법, 프레임워크 없이]
- express.js로 별도 서버 직접 운영
- TS 사용하고 싶으면 TS지원하는 nest.js 사용할 수도 있음
- 그러나 이 방법은 서버 환경 구성, 빌드 환경 작업때문에 복잡할 수 있음


[CSR에 SSR이나 SSG를 도입하는 방법, 프레임워크로]
- next.js
    : React에서 SSR, SSG 사용할 수 있게 해주는 프레임워크
    페이지 성격별로 SSR이나 SSG를 미리 정해두는 것이 가능
- gatsby
    : SSG에 최적화

- 하지만 프레임워크 사용시 직접 제어할 수 없는 블랙박스 영역이 생기게 되는 것이 단점
    (개발자가 직접 보거나 수정할 수 없는 부분이 발생)
    (React나 Vue와 같은 프론트 프레임워크는 DOM업데이트, 상태관리, 이벤트 처리 등과 같은 기능을 블랙박스로 만들어 손쉽게 사용
    이는 덜복잡하게 하지만 프레임워크 내부에서 발생하는 문제를 디버깅하거나 세부 커스터마이징하기 어렵다는 단점 있음)


[CSR + SSR = Universal Rendering, Isomorphic App]
- 초기 렌더링 방식으로 SSR 사용하고 그 이후에는 CSR을 사용하는 렌더링 방식
- CSR과 SSR의 장점을 각각 취함
- 대표적인 예 : next.js나 nuxt.js
    이는 React나 vue를 기반으로 하면서도 isomorphic 렌더링 지원


(ISOMORPHIC : 같은 모양의, 동일 구조의
서버와 클라이언트에서 동일한 코드가 동작하는 어플리케이션
서버와 클라이언트가 모두 같은 코드로 돌아감 -> 초기 로딩 속도를 보완하고 SEO를 개선, CSR의 장점을 가져갈 수 있음)


작동 순서
- 웹 어플리케이션을 최초 로딩할 때는 SSR 방식을 사용
    : 사용자는 페이지 더 빨리 보게 되고, 사용자 경험을 개선하고 SEO에도 좋음
- 이후 선택적으로 CSR, SSR 선택
    : 사용자가 웹 페이지 내에서 이동하거나 상호작용할 때마다 JS가 페이지를 동적으로 업데이트
    서버 부하를 줄이고 사용자 상호작용에 빠르게 반응


[어떤 서비스에 따라 어떤 걸 채택?]
CSR이 적합한 경우
- 유저와 상호작용이 많음
- 고객 개인 정보로 이루어진 페이지가 많아 검색 엔진에 노출될 필요가 없음

SSR이 적합한 경우
- 회사 홈페이지
- 유저와 상호작용이 적음
- 페이지가 자주 업데이트됨

SSG가 적합한 경우
- 회사 홈페이지
- 누구에게나 같은 내용을 보여줌
- 업데이트를 거의 하지 않음

CSR + SSR (UNIVERSAL)
- 사용자에 따라 페이지 내용이 달라짐
- 빠른 인터렉션이 중요
- 화면 깜빡임이 안 됨
- 검색엔진 상위에 노출되어야 함
